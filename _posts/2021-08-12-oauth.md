---
title: OAuth 2.0
tags: OAuth-2.0 Authentication Cybersecurity
key: page-oauth_2_0
categories: [Cybersecurity, IAM]
author: hyoeun
math: true
mathjax_autoNumber: true
---

## Understanding OAuth 2.0: It's More Than Just Login

Many developers and engineers tend to think of OAuth 2.0 solely as a social login feature. However, the core of OAuth lies not in **Authentication**, but in **Authorization**. From a security professional's perspective, clearly distinguishing between these two is critically important.

* **Login (Authentication)**: This is like an employee using their company ID to pass through an entry gate. It's the process of verifying 'who' a person is and whether they are permitted to enter the company premises.
* **OAuth (Authorization)**: This is like a visitor receiving a visitor's pass at the front desk that grants them access only to a specific conference room. This pass does not allow them to roam everywhere in the building. In other words, it's the process of granting permissions for 'what a person can do'.

OAuth 2.0 is a standard protocol for securely delegating limited permissions to a third-party application (Client) to access resources (e.g., Google Drive files, Facebook friends list) on behalf of a user.

### OpenID Connect (OIDC) vs. OAuth 2.0

A concept that is often confused here is OpenID Connect (OIDC).

* **OAuth 2.0**: Its primary purpose is **Authorization**. It determines answers to questions like, "Should I allow this app to post on my Facebook wall?" or "Should I allow this app to read my Google Calendar events?" The result is an **Access Token**.
* **OIDC**: This is an **Authentication** layer built on top of OAuth 2.0. Its purpose is to "verify who the user is." The 'Login with Google' feature is a prime example of using OIDC, and the result is an **ID Token** containing the user's identity information.

Simply put, **OIDC tells you who the user is, and OAuth 2.0 grants an app permission to do things on that user's behalf.**

---

### The Main Roles in OAuth 2.0

Before understanding the flow, let's first get to know the actors in this play.

* **Resource Owner**: This is you, the user. As the owner of the data, you are the entity that grants access to your resources.
* **Client**: This is the third-party application that wants to access the user's resources. (e.g., a "Google Calendar" app wanting to integrate with "Slack").
* **Authorization Server**: This server authenticates the user and, with the user's consent, issues Access Tokens to the Client. (e.g., `accounts.google.com`).
* **Resource Server**: This is the server that stores the user's actual information (resources). It validates the Access Token and serves the requested resources. (e.g., `googleapis.com`).

---

### The Most Common Authentication Process: Authorization Code Grant Flow

Let's take the most common and secure method for web applications, the 'Authorization Code Grant Flow', as an example.

1.  **The User's Request (Authorization Request)**
    The user clicks a button like "Integrate with Google Account" in the client application. The client redirects the user to the Authorization Server (Google), sending along information like `client_id`, `redirect_uri`, `response_type=code`, and `scope` as query parameters.
    * `scope`: The scope of permissions the client is requesting (e.g., `profile`, `calendar.read`).

2.  **User Authentication and Consent**
    The user is taken to the Authorization Server's login page. After logging in, they see a consent screen like, "This app is requesting permission to access your profile information and read your calendar. Do you approve?" The user clicks 'Allow'.

3.  **Issuance of the Authorization Code**
    After confirming the user's consent, the Authorization Server redirects the user back to the `redirect_uri` previously specified by the client. It includes a single-use **Authorization Code** in the URL. This code is typically valid for a short period (usually around 10 minutes).

4.  **Token Exchange**
    Now, communication happens directly between the **client's back-end server** and the Authorization Server, not through the user's browser. The client server sends the authorization code it just received, along with its `client_id` and `client_secret`, to the Authorization Server's token endpoint.
    * `client_secret`: This acts like the client's password and must never be exposed publicly. This is why this step occurs on the back-end instead of the front-end.

5.  **Token Issuance**
    The Authorization Server validates the authorization code, `client_id`, and `client_secret`. If everything is valid, it finally issues an **Access Token** and a **Refresh Token** to the client.

6.  **API Call**
    The client uses the issued **Access Token** to make requests to the Resource Server (Google API) by including it in the `Authorization: Bearer <Access Token>` header. The Resource Server validates the Access Token and, if valid, returns the resources corresponding to the `scope` granted in the token (e.g., profile information, calendar data).

---

### Access Token

An **Access Token** is the key that proves permission to access the Resource Server.

* **Purpose**: It is a credential used to request protected resources (APIs) from the Resource Server.
* **Characteristics**:
    * **Short-lived**: For security, it typically has a short lifespan, from a few minutes to a few hours. If the token is stolen, the window of time an attacker can use it is limited.
    * **Stateless**: It often contains all the necessary information within the token itself (e.g., user identifier, permission scope, expiration time), as is the case with a JWT (JSON Web Token). The server only needs to validate the token, making it highly scalable as no state needs to be stored.
    * **Risk of Theft**: As a Bearer token, anyone who possesses it can use it as if they were the owner. Therefore, it must be transmitted securely over HTTPS and stored in a location inaccessible to scripts in the browser (e.g., an `HttpOnly` cookie).

### How to Check for Token Tampering (JWT Signature Verification)

How can the Resource Server trust an Access Token sent by a Client? What happens if someone intercepts and changes the token's content, like the `scope` or expiration time (`exp`)?

To solve this problem, many OAuth 2.0 implementations use **JWT (JSON Web Token)** as the format for Access Tokens. A JWT contains a digital signature within the token itself, allowing for immediate verification of its integrity.

A JWT is composed of three parts separated by dots (`.`): `Header.Payload.Signature`

1.  **Header**
    * Specifies the token type (JWT) and the hashing algorithm used to create the signature (e.g., `HS256`, `RS256`).
    * `{"alg": "HS256", "typ": "JWT"}`

2.  **Payload**
    * Contains the actual information of the token, known as **claims**. This includes the user's identifier (`sub`), permission scope (`scope`), expiration time (`exp`), issuer (`iss`), etc.
    * **Important**: The content of the payload is not encrypted, it is only **Base64 encoded**. Therefore, anyone can decode and view its contents. You must never include sensitive information like passwords in the payload.

3.  **Signature**
    * This is the core component that guarantees the token's **integrity**.
    * The signature is created by taking the Base64-encoded Header and Payload, joining them with a dot, and then hashing the result using the algorithm specified in the header (`alg`) and a **secret key**.
    * `HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)`

#### The Signature Verification Process

When a Resource Server receives an Access Token (JWT), it verifies its integrity through the following process:

1.  **Split the Token**: The received JWT is split into its Header, Payload, and Signature parts at the dots.
2.  **Recreate the Signature**: The server takes the separated Header and Payload and recalculates the signature using the same algorithm specified in the header and the **same secret key** that only it and the Authorization Server know.
    * *For asymmetric key methods (e.g., `RS256`)*, the Authorization Server signs with its **Private Key**, and the Resource Server verifies with the corresponding **Public Key**. This method is more scalable and secure.
3.  **Compare Signatures**: The newly generated signature is compared to the original signature that came with the token.

The result is simple:
* **Match**: If the signatures match, it means the token was issued by a trusted Authorization Server and has not been tampered with. The Resource Server can trust the content of the Payload and process the request.
* **Mismatch**: If the signatures do not match, it means that even a single bit in the Header or Payload has been altered. The token is considered tampered with or invalid and is immediately rejected (e.g., with a `401 Unauthorized` status).

Thanks to this signature verification mechanism, the Resource Server does not need to ask the Authorization Server, "Is this token valid?" every time. It can determine the token's authenticity quickly and efficiently on its own.

---

### Refresh Token

A **Refresh Token** is a special token used to obtain a new Access Token.

* **Purpose**: When an Access Token expires, the Refresh Token is used to automatically obtain a new one without requiring the user to log in (authenticate) again, thus improving the user experience.
* **Characteristics**:
    * **Long-lived**: It has a much longer lifespan than an Access Token, lasting for days or even months.
    * **High Security Requirement**: Because of its long life, it poses a significant security risk if stolen. It must be **stored encrypted in the client's secure database** and must never be exposed in a browser or mobile app.
    * **Possible One-time Use**: To enhance security, a practice known as 'Refresh Token Rotation' is recommended. When a refresh token is used to get a new access token, the old refresh token is invalidated and a new refresh token is issued alongside the new access token. This prevents the reuse of stolen refresh tokens.

From a penetration tester's perspective, OAuth 2.0 vulnerabilities often arise from improper `redirect_uri` validation, Cross-Site Request Forgery (CSRF) attacks, and token theft or exposure. Therefore, a precise understanding of this flow and the roles of each token is the first step toward building and auditing a secure system.

---

## ğŸ” OAuth 2.0, ì œëŒ€ë¡œ ì´í•´í•˜ê¸°: ë‹¨ìˆœí•œ ë¡œê·¸ì¸ì´ ì•„ë‹ˆë‹¤

ë§ì€ ê°œë°œìì™€ ì—”ì§€ë‹ˆì–´ë“¤ì´ OAuth 2.0ì„ ì†Œì…œ ë¡œê·¸ì¸ ê¸°ëŠ¥ìœ¼ë¡œë§Œ ìƒê°í•˜ëŠ” ê²½í–¥ì´ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ OAuthì˜ í•µì‹¬ì€ **ì¸ì¦(Authentication)ì´ ì•„ë‹Œ í—ˆê°€(Authorization)**ì— ìˆìŠµë‹ˆë‹¤. ë³´ì•ˆ ì „ë¬¸ê°€ì˜ ê´€ì ì—ì„œ ì´ ë‘˜ì„ ëª…í™•íˆ êµ¬ë¶„í•˜ëŠ” ê²ƒì€ ë§¤ìš° ì¤‘ìš”í•©ë‹ˆë‹¤.

  * **ë¡œê·¸ì¸ (ì¸ì¦)**: íšŒì‚¬ ì§ì›ì´ ì‚¬ì›ì¦ìœ¼ë¡œ ì¶œì… ê²Œì´íŠ¸ë¥¼ í†µê³¼í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ ì‚¬ëŒì€ 'ëˆ„êµ¬'ì´ë©°, íšŒì‚¬ì— ë“¤ì–´ì˜¬ ìê²©ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ê³¼ì •ì´ì£ .
  * **OAuth (í—ˆê°€)**: ì™¸ë¶€ ë°©ë¬¸ê°ì´ ì•ˆë‚´ ë°ìŠ¤í¬ì—ì„œ ë°©ë¬¸ì¦ì„ ë°›ì•„ íŠ¹ì • íšŒì˜ì‹¤ì—ë§Œ ë“¤ì–´ê°ˆ ìˆ˜ ìˆë„ë¡ í—ˆê°€ë°›ëŠ” ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤. ì´ ë°©ë¬¸ì¦ìœ¼ë¡œëŠ” ì‚¬ë‚´ ëª¨ë“  ê³³ì„ ëŒì•„ë‹¤ë‹ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì¦‰, 'ë¬´ì—‡ì„ í•  ìˆ˜ ìˆëŠ”ì§€'ì— ëŒ€í•œ ê¶Œí•œì„ ë¶€ì—¬í•˜ëŠ” ê³¼ì •ì…ë‹ˆë‹¤.

OAuth 2.0ì€ ì´ì²˜ëŸ¼ ì œ3ì˜ ì• í”Œë¦¬ì¼€ì´ì…˜(Client)ì—ê²Œ ë¦¬ì†ŒìŠ¤(ì˜ˆ: êµ¬ê¸€ ë“œë¼ì´ë¸Œ íŒŒì¼, í˜ì´ìŠ¤ë¶ ì¹œêµ¬ ëª©ë¡)ì— ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ì œí•œëœ ê¶Œí•œì„ ì•ˆì „í•˜ê²Œ ìœ„ì„(Delegate)í•˜ëŠ” í‘œì¤€ í”„ë¡œí† ì½œì…ë‹ˆë‹¤.

### OpenID Connect (OIDC) vs. OAuth 2.0

ì—¬ê¸°ì„œ ìì£¼ í˜¼ë™ë˜ëŠ” ê°œë…ì´ OpenID Connect(OIDC)ì…ë‹ˆë‹¤.

  * **OAuth 2.0**: **í—ˆê°€(Authorization)**ê°€ ì£¼ ëª©ì ì…ë‹ˆë‹¤. "ì´ ì•±ì´ ë‚´ í˜ì´ìŠ¤ë¶ ë‹´ë²¼ë½ì— ê¸€ì„ ì“°ë„ë¡ í—ˆë½í• ê¹Œ?" ë˜ëŠ” "ë‚´ êµ¬ê¸€ ìº˜ë¦°ë” ì¼ì •ì„ ì½ë„ë¡ í—ˆë½í• ê¹Œ?"ë¥¼ ê²°ì •í•©ë‹ˆë‹¤. ê²°ê³¼ë¬¼ì€ **Access Token**ì…ë‹ˆë‹¤.
  * **OIDC**: OAuth 2.0 ìœ„ì— êµ¬ì¶•ëœ **ì¸ì¦(Authentication)** ê³„ì¸µì…ë‹ˆë‹¤. "ì´ ì‚¬ìš©ìê°€ ëˆ„êµ¬ì¸ì§€ í™•ì¸"í•˜ëŠ” ê²ƒì´ ëª©ì ì…ë‹ˆë‹¤. 'êµ¬ê¸€ ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸' ê¸°ëŠ¥ì´ ë°”ë¡œ OIDCë¥¼ ì‚¬ìš©í•˜ëŠ” ëŒ€í‘œì ì¸ ì˜ˆì´ë©°, ê²°ê³¼ë¬¼ë¡œ ì‚¬ìš©ìì˜ ì‹ ì› ì •ë³´ê°€ ë‹´ê¸´ **ID Token**ì„ ë°›ìŠµë‹ˆë‹¤.

ê°„ë‹¨íˆ ë§í•´, **OIDCëŠ” ì‚¬ìš©ìê°€ ëˆ„êµ¬ì¸ì§€ ì•Œë ¤ì£¼ê³ , OAuth 2.0ì€ ê·¸ ì‚¬ìš©ìë¥¼ ëŒ€ì‹ í•´ ì•±ì´ ë¬´ì—‡ì„ í•  ìˆ˜ ìˆëŠ”ì§€ í—ˆë½í•´ ì¤ë‹ˆë‹¤.**

-----

### ğŸ›ï¸ OAuth 2.0ì˜ ì£¼ìš” ì°¸ì—¬ì (Roles)

íë¦„ì„ ì´í•´í•˜ê¸° ì „ì—, ë¨¼ì € ì—°ê·¹ì˜ ë“±ì¥ì¸ë¬¼ì„ ì•Œì•„ë´…ì‹œë‹¤.

  * **Resource Owner (ì‚¬ìš©ì)**: ğŸ§‘â€ğŸ’» ë°”ë¡œ ë‹¹ì‹ ì…ë‹ˆë‹¤. ë°ì´í„°ì˜ ì£¼ì¸ìœ¼ë¡œ, ìì‹ ì˜ ë¦¬ì†ŒìŠ¤ì— ëŒ€í•œ ì ‘ê·¼ ê¶Œí•œì„ ë¶€ì—¬í•˜ëŠ” ì£¼ì²´ì…ë‹ˆë‹¤.
  * **Client (í´ë¼ì´ì–¸íŠ¸)**: ì‚¬ìš©ìì˜ ë¦¬ì†ŒìŠ¤ì— ì ‘ê·¼í•˜ë ¤ëŠ” ì œ3ì ì• í”Œë¦¬ì¼€ì´ì…˜ì…ë‹ˆë‹¤. (ì˜ˆ: 'ìŠ¬ë™'ê³¼ ì—°ë™í•˜ë ¤ëŠ” 'êµ¬ê¸€ ìº˜ë¦°ë”' ì•±)
  * **Authorization Server (ê¶Œí•œ ì„œë²„)**: ğŸ›¡ï¸ ì‚¬ìš©ìë¥¼ ì¸ì¦í•˜ê³ , ì‚¬ìš©ìì˜ ë™ì˜ë¥¼ ë°›ì•„ Clientì—ê²Œ Access Tokenì„ ë°œê¸‰í•˜ëŠ” ì„œë²„ì…ë‹ˆë‹¤. (ì˜ˆ: `accounts.google.com`)
  * **Resource Server (ë¦¬ì†ŒìŠ¤ ì„œë²„)**: ğŸ—„ï¸ ì‚¬ìš©ìì˜ ì‹¤ì œ ì •ë³´(ë¦¬ì†ŒìŠ¤)ë¥¼ ì €ì¥í•˜ê³  ìˆëŠ” ì„œë²„ì…ë‹ˆë‹¤. Access Tokenì„ ê²€ì¦í•˜ê³  ìš”ì²­ëœ ë¦¬ì†ŒìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤. (ì˜ˆ: `googleapis.com`)

-----

### ğŸ”‘ ê°€ì¥ ì¼ë°˜ì ì¸ ì¸ì¦ ê³¼ì •: Authorization Code Grant Flow

ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ê°€ì¥ í”í•˜ê³  ì•ˆì „í•œ ë°©ì‹ì¸ 'ì¸ê°€ ì½”ë“œ ìŠ¹ì¸ íë¦„'ì„ ì˜ˆë¡œ ë“¤ì–´ë³´ê² ìŠµë‹ˆë‹¤.

1.  **ì‚¬ìš©ìì˜ ìš”ì²­ (Authorization Request)**
    ì‚¬ìš©ìê°€ í´ë¼ì´ì–¸íŠ¸ ì•±ì—ì„œ "Google ê³„ì •ìœ¼ë¡œ ì—°ë™í•˜ê¸°" ê°™ì€ ë²„íŠ¼ì„ í´ë¦­í•©ë‹ˆë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” ì‚¬ìš©ìë¥¼ ê¶Œí•œ ì„œë²„(Google)ë¡œ ë¦¬ë””ë ‰ì…˜ì‹œí‚¤ë©°, ì´ë•Œ `client_id`, `redirect_uri`, `response_type=code`, `scope` ê°™ì€ ì •ë³´ë¥¼ ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°ë¡œ í•¨ê»˜ ë³´ëƒ…ë‹ˆë‹¤.

      * `scope`: í´ë¼ì´ì–¸íŠ¸ê°€ ìš”ì²­í•˜ëŠ” ê¶Œí•œì˜ ë²”ìœ„ì…ë‹ˆë‹¤. (ì˜ˆ: `profile`, `calendar.read`)

2.  **ì‚¬ìš©ì ì¸ì¦ ë° ë™ì˜ (User Consent)**
    ì‚¬ìš©ìëŠ” ê¶Œí•œ ì„œë²„(Google)ì˜ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™í•©ë‹ˆë‹¤. ë¡œê·¸ì¸ì„ ë§ˆì¹˜ë©´, "ì´ ì•±ì´ ë‹¹ì‹ ì˜ í”„ë¡œí•„ ì •ë³´ì™€ ìº˜ë¦°ë” ì½ê¸° ê¶Œí•œì„ ìš”ì²­í•©ë‹ˆë‹¤. í—ˆìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?"ì™€ ê°™ì€ ë™ì˜ í™”ë©´(Consent screen)ì„ ë³´ê²Œ ë©ë‹ˆë‹¤. ì‚¬ìš©ìê°€ 'í—ˆìš©'ì„ í´ë¦­í•©ë‹ˆë‹¤.

3.  **ì¸ê°€ ì½”ë“œ ë°œê¸‰ (Authorization Code)**
    ê¶Œí•œ ì„œë²„ëŠ” ì‚¬ìš©ìì˜ ë™ì˜ë¥¼ í™•ì¸í•œ í›„, ì‚¬ìš©ìë¥¼ í´ë¼ì´ì–¸íŠ¸ê°€ ë¯¸ë¦¬ ì§€ì •í•œ `redirect_uri`ë¡œ ë‹¤ì‹œ ë¦¬ë””ë ‰ì…˜ì‹œí‚µë‹ˆë‹¤. ì´ë•Œ URLì— **ì¼íšŒì„± ì¸ê°€ ì½”ë“œ(Authorization Code)**ë¥¼ í¬í•¨í•˜ì—¬ ë³´ëƒ…ë‹ˆë‹¤. ì´ ì½”ë“œëŠ” ì§§ì€ ì‹œê°„(ë³´í†µ 10ë¶„) ë™ì•ˆë§Œ ìœ íš¨í•©ë‹ˆë‹¤.

4.  **í† í° êµí™˜ (Token Exchange)**
    ì´ì œ ì‚¬ìš©ìì˜ ë¸Œë¼ìš°ì €ê°€ ì•„ë‹Œ, **í´ë¼ì´ì–¸íŠ¸ì˜ ë°±ì—”ë“œ ì„œë²„**ê°€ ì§ì ‘ ê¶Œí•œ ì„œë²„ì™€ í†µì‹ í•©ë‹ˆë‹¤. í´ë¼ì´ì–¸íŠ¸ ì„œë²„ëŠ” ë°©ê¸ˆ ë°›ì€ ì¸ê°€ ì½”ë“œì™€ ìì‹ ì˜ `client_id`, `client_secret`ì„ ê¶Œí•œ ì„œë²„ì˜ í† í° ë°œê¸‰ ì—”ë“œí¬ì¸íŠ¸ë¡œ ë³´ëƒ…ë‹ˆë‹¤.

      * `client_secret`: í´ë¼ì´ì–¸íŠ¸ì˜ ë¹„ë°€ë²ˆí˜¸ì™€ ê°™ì€ ì—­í• ì„ í•˜ë©°, ì ˆëŒ€ ì™¸ë¶€ì— ë…¸ì¶œë˜ì–´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤. ì´ ê³¼ì •ì´ í”„ë¡ íŠ¸ì—”ë“œê°€ ì•„ë‹Œ ë°±ì—”ë“œì—ì„œ ì´ë£¨ì–´ì§€ëŠ” ì´ìœ ì…ë‹ˆë‹¤.

5.  **í† í° ë°œê¸‰ (Token Issuance)**
    ê¶Œí•œ ì„œë²„ëŠ” ì¸ê°€ ì½”ë“œ, `client_id`, `client_secret`ì„ ëª¨ë‘ ê²€ì¦í•œ í›„, ë§ˆì¹¨ë‚´ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ **Access Token**ê³¼ **Refresh Token**ì„ ë°œê¸‰í•©ë‹ˆë‹¤.

6.  **API í˜¸ì¶œ (API Call)**
    í´ë¼ì´ì–¸íŠ¸ëŠ” ë°œê¸‰ë°›ì€ **Access Token**ì„ `Authorization: Bearer <Access Token>` í—¤ë”ì— ë‹´ì•„ ë¦¬ì†ŒìŠ¤ ì„œë²„(Google API)ì— APIë¥¼ ìš”ì²­í•©ë‹ˆë‹¤. ë¦¬ì†ŒìŠ¤ ì„œë²„ëŠ” Access Tokenì˜ ìœ íš¨ì„±ì„ ê²€ì¦í•˜ê³ , í† í°ì— ë¶€ì—¬ëœ `scope`ì— ë§ëŠ” ë¦¬ì†ŒìŠ¤(í”„ë¡œí•„ ì •ë³´, ìº˜ë¦°ë” ë°ì´í„° ë“±)ë¥¼ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ë‹¬í•©ë‹ˆë‹¤.

<img alt=" " src="/assets/images/oauth.jpeg" width="600px">

-----

### Access Token (ì•¡ì„¸ìŠ¤ í† í°)

**ì•¡ì„¸ìŠ¤ í† í°(Access Token)**ì€ ë¦¬ì†ŒìŠ¤ ì„œë²„ì— ëŒ€í•œ ì ‘ê·¼ ê¶Œí•œì„ ì¦ëª…í•˜ëŠ” ì—´ì‡ ì…ë‹ˆë‹¤.

  * **ëª©ì **: ë¦¬ì†ŒìŠ¤ ì„œë²„ì— ë³´í˜¸ëœ ë¦¬ì†ŒìŠ¤(API)ë¥¼ ìš”ì²­í•  ë•Œ ì‚¬ìš©ë˜ëŠ” ìê²© ì¦ëª…ì…ë‹ˆë‹¤.
  * **íŠ¹ì§•**:
      * **ì§§ì€ ìˆ˜ëª… (Short-lived)**: ë³´ì•ˆì„ ìœ„í•´ ë³´í†µ ëª‡ ë¶„ì—ì„œ ëª‡ ì‹œê°„ ì •ë„ì˜ ì§§ì€ ìœ íš¨ ê¸°ê°„ì„ ê°€ì§‘ë‹ˆë‹¤. ë§Œì•½ í† í°ì´ íƒˆì·¨ë˜ë”ë¼ë„ ê³µê²©ìê°€ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì‹œê°„ì´ ì œí•œë©ë‹ˆë‹¤.
      * **Stateless**: í† í° ìì²´ì— í•„ìš”í•œ ì •ë³´(ì‚¬ìš©ì ì‹ë³„ì, ê¶Œí•œ ë²”ìœ„, ë§Œë£Œ ì‹œê°„ ë“±)ë¥¼ ë‹´ê³  ìˆëŠ” ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤ (ì˜ˆ: JWT - JSON Web Token). ì„œë²„ëŠ” í† í°ë§Œ ê²€ì¦í•˜ë©´ ë˜ë¯€ë¡œ ìƒíƒœë¥¼ ì €ì¥í•  í•„ìš”ê°€ ì—†ì–´ í™•ì¥ì„±ì´ ì¢‹ìŠµë‹ˆë‹¤.
      * **íƒˆì·¨ ìœ„í—˜**: Bearer í† í°ì´ë¯€ë¡œ, ì´ í† í°ì„ íšë“í•œ ì‚¬ëŒì€ ëˆ„êµ¬ë‚˜ í† í°ì˜ ì£¼ì¸ í–‰ì„¸ë¥¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ HTTPSë¥¼ í†µí•´ ì•ˆì „í•˜ê²Œ ì „ì†¡í•˜ê³ , ë¸Œë¼ìš°ì €ì—ì„œëŠ” ìŠ¤í¬ë¦½íŠ¸ê°€ ì ‘ê·¼í•˜ê¸° ì–´ë ¤ìš´ ê³³(ì˜ˆ: `HttpOnly` ì¿ í‚¤)ì— ì €ì¥í•˜ëŠ” ê²ƒì´ ê¶Œì¥ë©ë‹ˆë‹¤.

### âœï¸ í† í° ë³€ì¡°, ì–´ë–»ê²Œ í™•ì¸í• ê¹Œ? (JWT ì„œëª… ê²€ì¦)

í´ë¼ì´ì–¸íŠ¸ê°€ ë¦¬ì†ŒìŠ¤ ì„œë²„ë¡œ ì „ë‹¬í•˜ëŠ” Access Tokenì€ ì–´ë–»ê²Œ ì‹ ë¢°í•  ìˆ˜ ìˆì„ê¹Œìš”? ì¤‘ê°„ì— ëˆ„êµ°ê°€ í† í°ì˜ ë‚´ìš©(ì˜ˆ: ê¶Œí•œ ë²”ìœ„ `scope`ë‚˜ ë§Œë£Œ ì‹œê°„ `exp`)ì„ ë°”ê¾¸ë©´ ì–´ë–»ê²Œ ë ê¹Œìš”?

ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë§ì€ OAuth 2.0 êµ¬í˜„ì—ì„œëŠ” **JWT(JSON Web Token)**ë¥¼ Access Tokenìœ¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤. JWTëŠ” í† í° ìì²´ì— 'ì „ì ì„œëª…'ì„ í¬í•¨í•˜ë¯€ë¡œ, ë³€ì¡° ì—¬ë¶€ë¥¼ ì¦‰ì‹œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

JWTëŠ” `.`ì„ ê¸°ì¤€ìœ¼ë¡œ ì„¸ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ë‰©ë‹ˆë‹¤: `Header.Payload.Signature`

1.  **Header (í—¤ë”)**
    * í† í°ì˜ ì¢…ë¥˜(JWT)ì™€ ì„œëª… ìƒì„±ì— ì‚¬ìš©ëœ í•´ì‹± ì•Œê³ ë¦¬ì¦˜(ì˜ˆ: `HS256`, `RS256`)ì´ ëª…ì‹œë©ë‹ˆë‹¤.
    * `{"alg": "HS256", "typ": "JWT"}`

2.  **Payload (í˜ì´ë¡œë“œ)**
    * í† í°ì— ë‹´ê¸´ ì‹¤ì œ ì •ë³´, ì¦‰ **í´ë ˆì„(Claim)**ì´ ë“¤ì–´ê°‘ë‹ˆë‹¤. ì‚¬ìš©ìì˜ ì‹ë³„ì(`sub`), ê¶Œí•œ ë²”ìœ„(`scope`), ë§Œë£Œ ì‹œê°„(`exp`), ë°œê¸‰ì(`iss`) ë“±ì´ ì—¬ê¸°ì— í¬í•¨ë©ë‹ˆë‹¤.
    * **ì¤‘ìš”**: í˜ì´ë¡œë“œì˜ ë‚´ìš©ì€ ì•”í˜¸í™”ëœ ê²ƒì´ ì•„ë‹ˆë¼ **Base64ë¡œ ì¸ì½”ë”©**ëœ ê²ƒë¿ì…ë‹ˆë‹¤. ë”°ë¼ì„œ ëˆ„êµ¬ë‚˜ ë””ì½”ë”©í•´ì„œ ë‚´ìš©ì„ ë³¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ë¹„ë°€ë²ˆí˜¸ì™€ ê°™ì€ ë¯¼ê° ì •ë³´ë¥¼ ë‹´ì•„ì„œëŠ” ì ˆëŒ€ ì•ˆ ë©ë‹ˆë‹¤.

3.  **Signature (ì„œëª…)**
    * ì´ ë¶€ë¶„ì´ ë°”ë¡œ í† í°ì˜ **ë¬´ê²°ì„±(Integrity)**ì„ ë³´ì¥í•˜ëŠ” í•µì‹¬ì…ë‹ˆë‹¤.
    * ì„œëª…ì€ `Header`ì™€ `Payload`ë¥¼ Base64 ì¸ì½”ë”©í•œ ê°’ì„ `.`ìœ¼ë¡œ ì—°ê²°í•˜ê³ , ì´ë¥¼ Headerì— ëª…ì‹œëœ ì•Œê³ ë¦¬ì¦˜(`alg`)ê³¼ **ë¹„ë°€ í‚¤(Secret Key)**ë¥¼ ì‚¬ìš©í•´ í•´ì‹±í•˜ì—¬ ìƒì„±í•©ë‹ˆë‹¤.
    * `HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)`

#### ì„œëª… ê²€ì¦ ê³¼ì •

ë¦¬ì†ŒìŠ¤ ì„œë²„ëŠ” í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° Access Token(JWT)ì„ ë°›ìœ¼ë©´ ë‹¤ìŒê³¼ ê°™ì€ ê³¼ì •ìœ¼ë¡œ ë³€ì¡° ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

1.  **í† í° ë¶„ë¦¬**: ë°›ì€ JWTë¥¼ `.` ê¸°ì¤€ìœ¼ë¡œ Header, Payload, Signatureë¡œ ë¶„ë¦¬í•©ë‹ˆë‹¤.
2.  **ì„œëª… ì¬ìƒì„±**: ë¶„ë¦¬í•œ Headerì™€ Payload, ê·¸ë¦¬ê³  ë¦¬ì†ŒìŠ¤ ì„œë²„ë§Œ ì•Œê³  ìˆëŠ” **ë™ì¼í•œ ë¹„ë°€ í‚¤(Secret Key)**ë¥¼ ì‚¬ìš©í•´ Headerì— ëª…ì‹œëœ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì„œëª…ì„ ë‹¤ì‹œ ê³„ì‚°í•©ë‹ˆë‹¤.
    * *ë¹„ëŒ€ì¹­ í‚¤ ë°©ì‹(ì˜ˆ: `RS256`)*ì˜ ê²½ìš°, ê¶Œí•œ ì„œë²„ì˜ **Private Key**ë¡œ ì„œëª…í•˜ê³  ë¦¬ì†ŒìŠ¤ ì„œë²„ëŠ” ëŒ€ì‘ë˜ëŠ” **Public Key**ë¡œ ì„œëª…ì„ ê²€ì¦í•©ë‹ˆë‹¤. ì´ ë°©ì‹ì´ ë” í™•ì¥ì„± ìˆê³  ì•ˆì „í•©ë‹ˆë‹¤.
3.  **ì„œëª… ë¹„êµ**: í† í°ì— ë‹´ê²¨ì˜¨ ê¸°ì¡´ Signatureì™€ ë¦¬ì†ŒìŠ¤ ì„œë²„ê°€ ë°©ê¸ˆ ìƒˆë¡œ ìƒì„±í•œ ì„œëª…ì„ ë¹„êµí•©ë‹ˆë‹¤.

ê²°ê³¼ëŠ” ê°„ë‹¨í•©ë‹ˆë‹¤.
* **ì¼ì¹˜**: ì„œëª…ì´ ì¼ì¹˜í•˜ë©´, í† í°ì€ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ê¶Œí•œ ì„œë²„ë¡œë¶€í„° ë°œê¸‰ë˜ì—ˆìœ¼ë©° ì¤‘ê°„ì— ì „í˜€ ë³€ì¡°ë˜ì§€ ì•Šì•˜ìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ë¦¬ì†ŒìŠ¤ ì„œë²„ëŠ” ì•ˆì‹¬í•˜ê³  Payloadì˜ ë‚´ìš©ì„ ì‹ ë¢°í•˜ì—¬ ìš”ì²­ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
* **ë¶ˆì¼ì¹˜**: ì„œëª…ì´ ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´, Headerë‚˜ Payload ì¤‘ ì–´ëŠ í•œ ë¶€ë¶„ì´ë¼ë„ 1ë¹„íŠ¸ë¼ë„ ë³€ê²½ë˜ì—ˆìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì´ í† í°ì€ ë³€ì¡°ë˜ì—ˆê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•Šì€ ê²ƒìœ¼ë¡œ ê°„ì£¼ë˜ì–´ ì¦‰ì‹œ ê±°ë¶€(`401 Unauthorized`)ë©ë‹ˆë‹¤.

ì´ëŸ¬í•œ ì„œëª… ê²€ì¦ ë©”ì»¤ë‹ˆì¦˜ ë•ë¶„ì—, ë¦¬ì†ŒìŠ¤ ì„œë²„ëŠ” ë§¤ë²ˆ ê¶Œí•œ ì„œë²„ì— "ì´ í† í°ì´ ìœ íš¨í•œê°€?"ë¼ê³  ë¬¼ì–´ë³¼ í•„ìš” ì—†ì´ ìì²´ì ìœ¼ë¡œ í† í°ì˜ ì§„ìœ„ ì—¬ë¶€ë¥¼ ë¹ ë¥´ê³  íš¨ìœ¨ì ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


-----

### Refresh Token (ë¦¬í”„ë ˆì‹œ í† í°)

**ë¦¬í”„ë ˆì‹œ í† í°(Refresh Token)**ì€ ìƒˆë¡œìš´ ì•¡ì„¸ìŠ¤ í† í°ì„ ë°œê¸‰ë°›ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” íŠ¹ë³„í•œ í† í°ì…ë‹ˆë‹¤.

  * **ëª©ì **: ì•¡ì„¸ìŠ¤ í† í°ì´ ë§Œë£Œë˜ì—ˆì„ ë•Œ, ì‚¬ìš©ìê°€ ë‹¤ì‹œ ë¡œê·¸ì¸(ì¸ì¦)í•˜ëŠ” ë¶ˆí¸í•¨ ì—†ì´ ìƒˆë¡œìš´ ì•¡ì„¸ìŠ¤ í† í°ì„ ìë™ìœ¼ë¡œ ë°œê¸‰ë°›ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.
  * **íŠ¹ì§•**:
      * **ê¸´ ìˆ˜ëª… (Long-lived)**: ì•¡ì„¸ìŠ¤ í† í°ë³´ë‹¤ í›¨ì”¬ ê¸´ ìœ íš¨ ê¸°ê°„(ë©°ì¹ , ëª‡ ë‹¬)ì„ ê°€ì§‘ë‹ˆë‹¤.
      * **ë†’ì€ ë³´ì•ˆ ìš”êµ¬**: ê¸´ ìˆ˜ëª…ì„ ê°€ì§„ ë§Œí¼ íƒˆì·¨ë  ê²½ìš° ì‹¬ê°í•œ ë³´ì•ˆ ìœ„í˜‘ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ **í´ë¼ì´ì–¸íŠ¸ì˜ ì•ˆì „í•œ ë°ì´í„°ë² ì´ìŠ¤ì— ì•”í˜¸í™”í•˜ì—¬ ì €ì¥**í•´ì•¼ í•˜ë©°, ì ˆëŒ€ ë¸Œë¼ìš°ì €ë‚˜ ëª¨ë°”ì¼ ì•± ë‚´ë¶€ì— ë…¸ì¶œí•´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤.
      * **ì¼íšŒì„± ì‚¬ìš© ê°€ëŠ¥ (One-time use)**: ë³´ì•ˆ ê°•í™”ë¥¼ ìœ„í•´ ë¦¬í”„ë ˆì‹œ í† í°ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆ ì•¡ì„¸ìŠ¤ í† í°ì„ ë°œê¸‰ë°›ìœ¼ë©´, ê¸°ì¡´ ë¦¬í”„ë ˆì‹œ í† í°ì€ ë¬´íš¨í™”ë˜ê³  ìƒˆë¡œìš´ ë¦¬í”„ë ˆì‹œ í† í°ì„ í•¨ê»˜ ë°œê¸‰í•˜ëŠ” 'ë¦¬í”„ë ˆì‹œ í† í° ìˆœí™˜(Refresh Token Rotation)' ë°©ì‹ì´ ê¶Œì¥ë©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ íƒˆì·¨ëœ ë¦¬í”„ë ˆì‹œ í† í°ì˜ ì¬ì‚¬ìš©ì„ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

íœí…ŒìŠ¤í„° ê´€ì ì—ì„œ OAuth 2.0ì˜ ì·¨ì•½ì ì€ ì£¼ë¡œ `redirect_uri` ê²€ì¦ ë¯¸í¡, CSRF(Cross-Site Request Forgery) ê³µê²©, í† í° íƒˆì·¨ ë° ë…¸ì¶œ ë“±ì—ì„œ ë°œìƒí•©ë‹ˆë‹¤. ë”°ë¼ì„œ ì´ íë¦„ê³¼ ê° í† í°ì˜ ì—­í• ì„ ì •í™•íˆ ì´í•´í•˜ëŠ” ê²ƒì´ ì•ˆì „í•œ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ê³  ì ê²€í•˜ëŠ” ì²«ê±¸ìŒì´ ë  ê²ƒì…ë‹ˆë‹¤.