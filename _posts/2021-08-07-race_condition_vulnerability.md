---
title: Race Condition Vulnerability
tags: Race-Condition Vulnerabilities Cybersecurity
key: page-race_condition_vulnerability
categories: [Cybersecurity, Vulnerabilities]
author: hyoeun
math: true
mathjax_autoNumber: true
---

## Introduction
* Race condition problem이란 when two concurrent threads of execution access a shared resource in a way that unintentionally produces different results depending on the sequence or timing of the processes of threads이다.
* Race condition vulnerability는 간단하게 말하면 check와 use사이의 window의 허점을 노리는 공격이다.
* 이것을 time-of-check to time-of-use(TOCTTOU)라고 부른다.
* 또 다른 공격으로는 Dirty COW라는 공격이 있는데 이거는 다음 포스팅에서 다룰 예정이다.


## Race Condition Vulnerability
* real ID가 normal user이고 effective user ID가 root일때 /tmp 디렉토리와 같은 world-writable한 곳에 접근을 하기 위한 코드에서 발생 할 수 있는 취약점이다.
* access()는 real ID와 file의 permission을 비교해서 permission을 가지고 있으면 0을 리턴한다. 즉, 정상 작동하면 0을 return한다는 말이다.
* open()함수는 real ID가 아닌 effective ID를 가지고 file의 permission을 확인해서 연다.
* open()함수는 정상적으로 파일을 열었을 시에는 사용되지 않고 있는 file descriptor중에서 가장 낮은 번호의 양수 값을 리턴한다.
* 이 공격에서의 핵심은 root 권한을 가진 privileged program이 real ID를 확인하는 access를 통과한 후 effective ID를 확인하는 open에서 생기는 허점을 노리는 공격이다. check와 use사이의 window에서 symlink를 통해 race를 이기고 공격을 하는 것이다.
<img alt=" " src="/assets/images/tocttou_attack.png" width="400px" style="display: block;margin-left: auto;margin-right: auto;">

## Launch Attack

* protected file중에서 /etc/passwd에 root 아이디를 추가하면 모든 통제권을 가질 수 있게 된다.
* /etc/passwd에 사용자 비밀번호가 들어갈때에는 one-way hash value가 들어간다. 이때 adduser로 사용자를 생성할때 /etc/shadow에 입력한 비밀번호의 one-way hash value가 있을거고 그것을 /etc/passwd 파일에서 참고한다.
* 따라서 새로운 root 유저를 생성할때 비밀번호를 내가 아는 부분의 /etc/shadow 비밀번호를 참고할 것인지, adduser로 hash value생성후 가져올 것인지 아니면 U6aMy0wojraho라는 엔터값에 대한 hash value를 쓸 것인지 정해야한다.
* target program은 access와 open을 하는 구조(TOCTTOU)여야하고 attack_process 프로그램은 the window에서 symlinkn를 걸었다 풀었다 반복하는 프로그램이어야 한다. 적절한 usleep()코드로 background에서 계속 작용하면 된다. 마지막으로 이 모든 것을 자동적으로 실행시켜줄 shell script하나 짜서 공격하면 된다.

## Coiuntermeasure

1. how do we eliminate the window between check and use?
    * Atomic Operation
        * 이거는 os level의 support가 필요하다. open() system call의 경우 O_EXCL과 O_CREAT를 사용하면 file이 이미 있으면 열지 않게 된다. 따라서 symlink는 아예 사용조차 못하게 되는 것이다. 하지만 linux system에는 이 기능을 지원하지 않고 있다.
1. how do we prevent others from doing anything inside the window?
    * Principle of Least Privilege
        * access를 통해 확인 하는 것이 아니라 seteuid(getuid())를 통해서 애초에 과도한 권한 설정을 막는것이다.
1. how do we make it difficult for attackers to win the "race"?
    * Repeating Check and Use
        * 단순히 access, check의 횟수를 반복시키는것이다. 하지만 이것역시 여러번 race에서 이기면 되는 것이라서 강력한 countermeasure라고 하기는 힘들 것 같다.
1. how do we prevent attackers from causing damages after they have won the "race"?
    * Sticky Symlink Protection
        * Ubuntu에서 제공하는 protection mechanism이다.
        * 이거는 world-writable sticky directories(Such as /tmp)에만 적용된다.
        * sticky directory란 linux file system에서 sticky bit을 쓰는 directory를 의미한다.
        * sticky bit가 set되어 있으면 symlink's owner가 file's owner 혹은 the directory's owner가 아니면 rename이나 delete가 되지 않게 해준다.

## Refrence
* [COMPUTER SECURITY: A Hands-on Approach by Wenliang Du](https://www.amazon.com/Computer-Security-Hands-Approach-Wenliang/dp/154836794X)
* [Image - tocttou attack](https://csis.gmu.edu/ksun/AIT681-s19/notes/T13_race%20conditions.pdf)