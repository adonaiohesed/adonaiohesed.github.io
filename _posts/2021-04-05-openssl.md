---
title: Certificate Generation By Using OpenSSL
tags: Openssl Certificate-Creation Tools
key: page-openssl_certificate_creation
categories: [Cybersecurity, Cryptography]
author: hyoeun
---

### **Certificate Generation: Using OpenSSL to Create CA, Client, and Server Certificates**

This post will walk you through the process of using **OpenSSL** to set up your own **Certificate Authority (CA)** and then generate both **server** and **client certificates** based on it. This procedure is useful for securing internal systems, test environments, and for setting up basic TLS/SSL communication.

-----

### **1. Preparing the Environment**

First, create a dedicated directory for your certificates and set appropriate permissions for security. The `chmod 555` command gives read and execute permissions to all users but prevents write access, which helps protect the certificate files.

```console
$ mkdir /etc/pki/root
$ cd /etc/pki/root/

$ chmod 555 /etc/pki/root
$ chmod 555 /etc/pki/root/*
```

-----

### **2. Creating a Configuration File for IP Addresses (`extfile.cnf`)**

If a certificate does not include specific IP addresses, an SSL/TLS handshake can fail with a validation error when connecting directly via IP. For example, you might see an error like `x509: cannot validate certificate for <ip> because it doesn't contain any ip SANs`.

To prevent this, you need to create a configuration file that defines the **Subject Alternative Name (SAN)** field. This file lists the IP addresses for which the certificate will be considered valid.

```console
$ vi extfile.cnf
```

```
subjectAltName = IP:192.168.0.85, IP:192.168.0.86, IP:192.168.0.87
```

-----

### **3. Generating the Root CA (Server CA)**

The **Root CA** is the trusted authority that will sign all other certificates.

#### **3.1. Generate the CA Private Key**

First, create the **private key** for the CA. Using the `-des3` option encrypts the key, and you'll be prompted to enter a password which will be needed later for signing.

```console
$ openssl genrsa -des3 -out server.cakey.pem 2048
```

(Note: It's a best practice to explicitly specify a key length like 2048 or 4096 bits.)

#### **3.2. Generate the CA Public Key (Certificate)**

Use the CA private key to create a self-signed **root certificate** (`root.crt`). The `-x509` option creates a self-signed certificate from the key without needing a separate Certificate Signing Request (CSR).

```console
$ openssl req -new -x509 -key server.cakey.pem -out root.crt -days 3650
```

-----

### **4. Generating the Server Certificate**

Now, use the newly created CA to generate a **server certificate**. This certificate is what your web server (e.g., Apache, Nginx) will use.

#### **4.1. Generate the Server Private Key**

```console
$ openssl genrsa -out server.key 2048
```

#### **4.2. Generate the Server CSR**

Create a **Certificate Signing Request (CSR)** using the server's private key. This file is sent to the CA to request a signature.

```console
$ openssl req -new -key server.key -out server.csr
```

#### **4.3. Generate the Server Certificate (`.crt`)**

Sign the CSR using the CA's private key (`server.cakey.pem`) and root certificate (`root.crt`). Use the `-extfile` option to include the IP address information from `extfile.cnf` in the final certificate.

```console
$ openssl x509 -req -in server.csr -days 3650 -sha256 -CA root.crt -CAkey server.cakey.pem -CAcreateserial -out server.crt -extfile extfile.cnf
```

-----

### **5. Generating the Client Certificate**

A client certificate is used to authenticate a client to a server, typically in a mutual TLS (mTLS) setup.

#### **5.1. Generate the Client Private Key**

```console
$ openssl genrsa -out client.key 2048
```

#### **5.2. Generate the Client CSR**

```console
$ openssl req -new -key client.key -out client.csr
```

#### **5.3. Generate the Client Certificate (`.crt`)**

Sign the client CSR using the CA in the same way you did for the server certificate.

```console
$ openssl x509 -req -in client.csr -days 3650 -sha256 -CA root.crt -CAkey server.cakey.pem -CAcreateserial -out client.crt -extfile extfile.cnf
```

-----

### **인증서 생성 절차: OpenSSL을 활용한 CA 및 클라이언트/서버 인증서 만들기**

이 글에서는 OpenSSL을 사용하여 **CA(Certificate Authority)**를 직접 구축하고, 이를 기반으로 **서버 인증서**와 **클라이언트 인증서**를 생성하는 과정을 단계별로 설명합니다. 이 과정은 보안이 중요한 내부 시스템, 테스트 환경, 또는 TLS/SSL 통신을 위한 기본적인 인증서 설정에 유용합니다.

-----

### **1. 작업 환경 준비**

인증서를 저장할 디렉터리를 생성하고, 보안을 위해 적절한 권한을 설정하는 것이 중요합니다. `chmod 555` 명령어는 디렉터리 소유자와 그룹, 다른 사용자에게 **읽기(read)** 및 **실행(execute)** 권한만 부여하여 쓰기(write)를 방지합니다.

```console
$ mkdir /etc/pki/root
$ cd /etc/pki/root/

$ chmod 555 /etc/pki/root
$ chmod 555 /etc/pki/root/*
```

-----

### **2. IP 주소 추가를 위한 설정 파일 (`extfile.cnf`) 생성**

인증서에 특정 IP 주소를 포함시키지 않으면, IP 주소로 직접 접근할 때 SSL/TLS 핸드셰이크 과정에서 유효성 검증 오류가 발생할 수 있습니다. 예를 들어, `x509: cannot validate certificate for <ip> because it doesn't contain any ip SANs`와 같은 오류가 나타날 수 있습니다.

이러한 문제를 방지하기 위해 **SAN(Subject Alternative Name)** 필드를 정의하는 설정 파일을 미리 생성해야 합니다. 이 파일에는 인증서가 유효하게 인식될 IP 주소 목록을 명시합니다.

```console
$ vi extfile.cnf
```

```
subjectAltName = IP:192.168.0.85, IP:192.168.0.86, IP:192.168.0.87
```

-----

### **3. 루트 CA(서버 CA) 생성**

모든 인증서의 신뢰를 보장하는 **루트 CA**를 먼저 생성합니다. 이 CA는 다른 서버 및 클라이언트 인증서를 서명하는 데 사용됩니다.

#### **3.1. CA 개인 키 생성**

먼저 CA의 **개인 키(Private Key)**를 생성합니다. `-des3` 옵션을 사용하여 암호화된 키를 만들 수 있으며, 이때 입력하는 패스워드는 나중에 인증서 서명 시 사용됩니다.

```console
$ openssl genrsa -des3 -out server.cakey.pem 2048
```

(참고: 키 길이를 명시적으로 2048 또는 4096 비트로 지정하는 것이 권장됩니다.)

#### **3.2. CA 공개 키(인증서) 생성**

CA 개인 키를 사용하여 **루트 인증서**(`root.crt`)를 생성합니다. 이 과정에서 국가, 조직 등 인증서 정보를 입력하게 됩니다. `-x509` 옵션은 CSR(Certificate Signing Request) 없이 자체 서명된 인증서를 만듭니다.

```console
$ openssl req -new -x509 -key server.cakey.pem -out root.crt -days 3650
```

-----

### **4. 서버 인증서 생성**

이제 생성된 CA를 이용하여 **서버용 인증서**를 만듭니다. 이 인증서는 웹 서버(Apache, Nginx 등)에서 사용될 것입니다.

#### **4.1. 서버 개인 키 생성**

먼저 서버의 **개인 키**를 생성합니다. 이 키는 CA의 키와는 별개입니다.

```console
$ openssl genrsa -out server.key 2048
```

#### **4.2. 서버 CSR 생성**

서버 개인 키를 사용하여 **CSR(Certificate Signing Request)**을 생성합니다. 이 요청 파일은 CA에게 인증서 서명을 요청하는 데 사용됩니다.

```console
$ openssl req -new -key server.key -out server.csr
```

#### **4.3. 서버 인증서 (`.crt`) 생성**

생성한 CSR 파일에 CA 개인 키(`server.cakey.pem`)와 루트 인증서(`root.crt`)를 이용하여 서명함으로써 최종 **서버 인증서**를 만듭니다. 이때 `-extfile` 옵션으로 앞서 만든 `extfile.cnf`를 포함시켜 IP 주소 정보를 인증서에 추가합니다.

```console
$ openssl x509 -req -in server.csr -days 3650 -sha256 -CA root.crt -CAkey server.cakey.pem -CAcreateserial -out server.crt -extfile extfile.cnf
```

-----

### **5. 클라이언트 인증서 생성**

클라이언트 인증서는 서버와 달리 사용자를 식별하는 데 사용됩니다. 예를 들어, mTLS(mutual TLS) 환경에서 클라이언트가 서버에 자신을 인증할 때 사용됩니다.

#### **5.1. 클라이언트 개인 키 생성**

```console
$ openssl genrsa -out client.key 2048
```

#### **5.2. 클라이언트 CSR 생성**

```console
$ openssl req -new -key client.key -out client.csr
```

#### **5.3. 클라이언트 인증서 (`.crt`) 생성**

서버 인증서와 동일한 방식으로 CA를 사용하여 클라이언트 인증서에 서명합니다.

```console
$ openssl x509 -req -in client.csr -days 3650 -sha256 -CA root.crt -CAkey server.cakey.pem -CAcreateserial -out client.crt -extfile extfile.cnf
```